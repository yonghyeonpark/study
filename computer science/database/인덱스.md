# 인덱스

- 인덱스는 데이터베이스 테이블의 검색 속도를 향상시키기 위해 별도로 구성하는 데이터 구조입니다.
- 인덱스를 사용하면 읽기 속도는 향상되지만, 데이터가 추가되거나 수정되면 정렬 작업이 필요하므로 쓰기 속도는 저하됩니다.
- InnoDB 스토리지 엔진에서는 인덱스 설계가 특히 중요합니다.
<br>=> 넥스트 키락이 먼저 검색한 인덱스를 잠근 후 테이블 레코드를 잠그는 방식으로 동작하기 때문에, 적절한 인덱스가 없으면 불필요하게 많은 레코드가 잠기게 됩니다.
- 일반적인 DBMS에서는 `NULL` 값을 인덱스에 저장하지 않지만, MySQL은 NULL 값도 인덱스에 저장합니다.

## 순차 I/O와 랜덤 I/O

### 순차 I/O

- 디스크의 물리적으로 연속된 공간에 순차적으로 접근하여 I/O 작업을 수행합니다.
- 한 번의 헤드 이동으로 많은 양의 데이터를 처리할 수 있어 대용량 데이터 처리에 효율적입니다.

### 랜덤 I/O

- 디스크의 물리적으로 떨어진 공간에 임의로 접근하여 I/O 작업을 수행합니다.
- 잦은 헤드의 이동으로 인해 I/O 작업 부하가 크지만, 특정 데이터를 검색하고 처리하는 데는 효율적입니다.
- 데이터베이스 대부분의 작업이 작은 데이터에 대한 잦은 I/O를 필요로 하기 때문에, MySQL 서버는 그룹 커밋, 바이너리 로그 버퍼, InnoDB 로그 버퍼 등의 기능을 내장하고 있습니다.

## B-Tree 인덱스 (Balanced-Tree)

- B-Tree 인덱스는 컬럼의 값을 변형하지 않고 원래의 값을 그대로 이용하여 인덱싱하는 방식입니다.
- B-Tree의 자식 노드는 가변적인 개수를 가집니다.

### 구조

<img src="https://github.com/user-attachments/assets/c635f4b9-a4c2-45f5-8e58-f43e65a2cf84" width="500"><br>

- **루트 노드**
  - 트리 구조의 최상위에 있는 노드입니다.
- **브랜치 노드**
  - 루트 노드와 리프 노드 사이에 위치한 중간 노드입니다.
- **리프 노드**
  - 실제 데이터 레코드의 주솟값을 저장하고 있는 노드입니다.

### 인덱스 키 추가

- 새로운 키 값을 B-Tree에 저장할 때는 적절한 위치를 검색해야 하며, 리프 노드가 포화 상태일 경우 리프 노드 분리 작업이 필요하므로 키 추가 작업에는 많은 비용이 발생합니다.

### 인덱스 키 삭제

- 특정 키 값을 삭제할 때는 해당 키 값이 저장된 리프 노드를 찾아 삭제 마크를 하는 것으로 작업이 완료됩니다.
- 삭제 마크된 공간은 그대로 두거나 필요에 따라 재활용할 수 있습니다.
- 이 작업 역시 디스크 I/O가 필요한 작업입니다.

### 인덱스 키 수정

- 키 값의 수정 작접은 기존 키 값을 삭제한 후, 새로운 키 값을 추가하는 방식으로 처리됩니다.

### 인덱스 키 값의 크기

- 디스크의 읽기/쓰기 최소 작업 단위는 페이지 또는 블록입니다.
- 인덱스 역시 페이지 단위로 관리되므로, 인덱스 키 값의 크기가 커지면 데이터가 여러 페이지에 분산되어 디스크 읽기 횟수가 증가하고 그만큼 성능이 저하됩니다.
- 또한, InnoDB의 버퍼 풀 영역은 크기가 제한적이므로 캐시할 수 있는 레코드의 수가 감소하여 메모리 효율성이 떨어지게 됩니다.

### 선택도

- 전체 키 값 중 유니크한 값의 수를 의미합니다.
- 인덱스 키 값에서 중복된 값이 많을수록 선택도는 낮아지며, 이에 따라 조회 대상이 증가하여 조회 속도가 저하됩니다. 

### 인덱스의 가용성

- B-Tree 인덱스는 왼쪽 값을 기준으로 오른쪽 값이 정렬되어 있기 때문에, `like` 키워드를 뒷부분 일치 검색에 사용하면 인덱스를 사용할 수 없습니다.
- 이 외에도 인덱스 컬럼이 변형된 후 비교되거나 `NOT-EQUAL`로 비교되는 경우 등에는 작업 범위 결정 조건으로 인덱스를 사용할 수 없습니니다. (경우에 따라 체크 조건으로 인덱스를 사용할 수는 있습니다.)

## Hash 인덱스

- Hash 인덱스는 컬럼의 값으로 해시값을 계산하여 인덱싱하는 방법입니다.
- 매우 빠른 검색을 지원하지만, 값을 변형하여 인덱싱하므로 일부 검색이나 범위 검색에는 사용할 수 없습니다.
- 주로 메모리 기반의 데이터베이스에 많이 사용됩니다.

## 유니크 인덱스

- 동등 조건으로 검색할 때, 1건의 레코드만 찾으면 더 이상 탐색하지 않아도 된다는 것을 옵티마이저에게 알려줍니다.
- 보통 유니크하지 않은 세컨더리 인덱스와 큰 차이가 있을 것으로 생각하는데, 실제로 추가되는 작업은 읽기가 아닌 CPU에서의 컬럼 값을 비교 작업이므로 성능상 영향이 거의 없습니다.
- 유니크 인덱스의 쓰기 작업 시에는 중복된 값의 존재 여부를 확인하는 과정이 필요하므로, 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느립니다.
- MySQL에서는 유니크 인덱스에서 중복된 값을 체크할 때는 공유 락을, 쓰기를 할 때는 배타 락을 사용하기 때문에 데드락이 매우 빈번하게 발생합니다.
- 따라서 유일성이 반드시 보장되어야 하는 컬럼에 대해서만 유니크 인덱스를 생성하고, 성능 향상을 위해 불필요하게 유니크 인덱스를 생성하는 것은 피하는 것이 좋습니다.
- 컬럼에 유니크 제약 조건을 추가하면 자동으로 인덱스가 생성됩니다.

## 커버링 인덱스

- 쿼리 조회 결과가 인덱스에 해당하는 컬럼 값으로만 이루어진 것을 커버링 인덱스라고 합니다.
- 커버링 인덱스로 처리되는 쿼리는 디스크의 레코드를 읽지 않아도 되므로 랜덤 읽기가 감소하고, 그만큼 성능이 향상됩니다.

## 클러스터드 인덱스

<img src="https://github.com/user-attachments/assets/81b78a2c-1ead-4efa-87d4-88f4ef7110b6" width="500"><br>

- MySQL에서 클러스터드 인덱스는 InnoDB 스토리지 엔진에서만 지원됩니다.
- 클러스터드 인덱스는 테이블의 PK에 대해서만 적용되며, PK 값에 따라 레코드의 저장 위치가 결정됩니다.
- 일반적으로 데이터 파일의 레코드들은 특정 순서 없이 임의로 저장됩니다. (순서대로 저장되긴 하지만, 레코드가 삭제되어 빈 공간이 생기면 새로운 INSERT 시, 가능한 한 삭제된 공간을 재활용합니다.)
- 반면 InnoDB 테이블의 레코드들은 PK 순서에 따라 클러스터드되어 디스크에 저장됩니다.
- PK 값이 변경되면 해당 레코드의 물리적인 저장 위치도 함께 변경됩니다.
- 이러한 특성으로 인해 PK 기반의 검색은 매우 빠르지만, 레코드의 저장이나 PK의 변경은 상대적으로 느립니다.
- 세컨더리 인덱스를 위한 B-Tree의 리프 노드와는 달리 클러스터드 인덱스의 리프 노드에는 레코드의 모든 컬럼이 함께 저장되어 있습니다.

### 클러스터드 키 선택 방식

1. PK가 있으면 PK를 선택
2. PK가 없다면 NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 선택
3. 자동으로 유니크한 값을 가지도록, 증가되는 컬럼을 내부적으로 추가한 후 선택
   - 자동으로 추가된 PK는 사용자에게 노출되지 않으며, 쿼리 문장에 명시적으로 사용할 수 없습니다.
   - 이는 아무런 이점이 없으므로, 가능하다면 PK를 명시적으로 생성하는 것이 좋습니다.
- 만약 세컨더리 인덱스가, 실제 레코드가 저장된 주소를 가지고 있다면 클러스터드 키 값이 변경될 때마다 데이터 레코드의 주소가 변경되고, 이 변경 사항을 테이블의 모든 인덱스에 적용해야 합니다.
- 이러한 오버헤드를 방지하기 위해 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라, PK 값을 저장하도록 구현되어 있습니다.
- InnoDB에서 세컨더리 인덱스는 물리적 주소 대신 PK를 주소처럼 사용하므로, 논리적 주소를 가진다고 볼 수 있습니다.
- 따라서 InnoDB 테이블에서 인덱스로 레코드를 읽을 때는 데이터 파일을 바로 찾아가지 못하고, PK 값을 통해 PK 인덱스를 검색한 후, 해당 리프 노드의 레코드를 읽어야 합니다.

### 장점

- PK(클러스터드 키)로 검색할 때 처리 속도가 매우 빠릅니다.
- 테이블의 모든 세컨더리 인덱스가 PK를 포함하고 있어, 인덱스만으로 처리될 수 있는 경우가 많습니다.

### 단점

- 테이블의 모든 세컨더리 인덱스가 PK를 포함하므로 PK 값의 크기가 클 경우 전체적인 인덱스의 크기가 커집니다.
- 세컨더리 인덱스를 통해 검색할 때, PK로 다시 한번 검색해야 하므로 처리 속도가 느립니다.
- `INSERT` 시, PK에 의해 레코드의 저장 위치가 결정되기 때문에 처리 속도가 느립니다.

## 스캔 방식

### 풀 테이블 스캔 (Full Table Scan)

- 풀 테이블 스캔은 테이블 전체를 읽어들이는 방식입니다.
- 주로 순차 I/O를 사용합니다.

### 인덱스 레인지 스캔 (Index Range Scan)

<img src="https://github.com/user-attachments/assets/6c54e8d6-9d22-4b30-9a8f-d15544efa0f4" width="600"><br>

- 인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정되었을 때 사용하는 방식입니다.
- 인덱스 스캔으로 통해 리프 노드에 저장된 레코드 주소를 이용해 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 단위로 랜덤 I/O가 일어납니다.
- 인덱스를 통한 데이터 레코드 읽기는 많은 비용이 드는 작업이므로, 많은 양의 데이터를 읽어야 할 경우에는 테이블을 직접 읽는 것이 더 효율적입니다.
- 인덱스 레코드가 페이지 내에서 단방향으로만 연결되어 있어 역순 스캔이 정순 스캔보다 느립니다.

### 인덱스 풀 스캔 (Index Full Scan)

- 인덱스 풀 스캔은 인덱스의 처음부터 끝까지 모두 읽어들이는 방식입니다.
- 효율적인 방식은 아니며, 일반적으로 인덱스를 생성하는 목적이 아닙니다.
- 대표적으로 쿼리의 조건절에 사용된 컬럼이 인덱스의 선행 컬럼이 아닌 경우에 인덱스 풀 스캔 방식이 사용됩니다.

### 루스 인덱스 스캔 (Loose Index Scan)

- 루스 인덱스 스캔은 인덱스 레인지 스캔과 유사하게 동작하지만, 중간에 필요하지 않은 인덱스 키 값은 건너뛰고 다음으로 진행하는 형태로 처리합니다.
- 일반적으로 `GROUP BY` 절이나 집합 함수(`MAX`, `MIN`)에 대한 최적화를 수행할 때 사용됩니다.

### 인덱스 스킵 스캔

- 기존에는 멀티 컬럼 인덱스 사용 시, 조건에 선행 컬럼을 사용하지 않으면 인덱스를 사용할 수 없었습니다.
- MySQL 8.0부터는 옵티마이저가 선행 컬럼을 건너뛰어 인덱스 검색이 가능하도록 하는 인덱스 스킵 스캔 최적화 기능이 도입되었습니다.
- MySQL 옵티마이저는 먼저 선행 컬럼에서 유니크한 값을 모두 조회하여 주어진 쿼리의 조건으로 추가한 후, 쿼리를 다시 실행하는 방식으로 처리합니다.
- 따라서 선행 컬럼의 유니크한 값이 매우 많은 경우에는 오히려 쿼리 처리 성능이 저하될 수 있으므로, 선행 컬럼이 가진 유니크한 값의 개수가 적을때만 적용이 가능한 최적화 방식입니다.

# 외래키

- FK 제약이 설정되면 자동으로 연관된 테이블의 컬럼에 인덱스가 생성됩니다.
- 자식 테이블의 FK 컬럼을 변경(`INSERT`, `UPDATE`)할 때, 부모 테이블의 해당 레코드에 배타 락이 걸려있으면 락이 해제될 때까지 대기해야 합니다.

## 제약 조건

### RESTRICT

- 부모 테이블의 삭제나 수정 작업을 즉시 거부합니다.

### No ACTION

- InnoDB에서는 `RESTRICT`와 동일하게 동작하여 관련 외래키가 있으면 즉시 거부합니다.
- MySQL의 외래키 제약 조건에서 기본으로 설정되는 옵션입니다.

### CASCADE

- 상위 테이블에서 레코드를 삭제하거나 PK를 업데이트하면 하위 테이블의 일치하는 레코드도 자동으로 삭제 또는 업데이트됩니다.

### SET NULL

- 상위 테이블의 레코드를 삭제하거나 PK를 업데이트하면 하위 테이블의 FK 컬럼이 `NULL`로 설정됩니다.

### SET DEFAULT

- `SET NULL`과 유사한 동작을 하되, `NULL` 대신 지정한 기본값으로 설정됩니다.
- 이 설정은 MySQL 파서에서는 인식되지만, 실제로 InnoDB 스토리지 엔진은 이 기능을 지원하지 않습니다.

## 참고

- [Real MySQL 8.0](https://www.yes24.com/product/goods/103415627)
- [MySQL 공식 문서](https://dev.mysql.com/doc/refman/8.0/en/)