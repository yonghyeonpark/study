# 애플리케이션 계층(Application Layer)


# 전송 계층(Transport Layer)

- 전송 계층은 포트 번호를 통해 데이터를 보낼 애플리케이션을 알 수 있습니다.
  - Well-Known Port
    - 22(`SSH`)
    - 25(`SMTP`): 이메일 전송
    - 80(`HTTP`)
    - 110(`POP3`): 이메일 수신
    - 143(`IMAP4`): 이메일 수신 및 보관
    - 등등
  - 클라이언트는 동적 포트(Dynamic Port)를 사용하기 때문에 포트 번호가 정해져 있지 않고, 필요할 때, 운영체제가 비어 있는 포트를 자동으로 할당합니다.<br>(통신이 종료되면 사용하던 포트를 반납합니다.)
- 전송 계층의 대표적인 프로토콜은 `TCP`와 `UDP`가 있습니다.

## TCP

- 웹 혹은 이메일 등과 같이 데이터가 정확히 전달되어야 하는 통신에 적합합니다.
- 데이터 전송에, 신뢰성을 더하기 위해 데이터를 `세그먼트` 단위로 분할합니다.
<img src = "https://github.com/user-attachments/assets/636f4313-b256-4acd-843b-2cb57377335d" width="600" height="400"><br>
  1. Source Port
     - 송신지 포트 번호
  2. Destination Port
     - 수신지 포트 번호
  3. Sequence Number
     - 일련번호
  4. Acknowledgement Number
     - 확인 응답 번호
  5. Data Offset
     - TCP 헤더의 길이
  6. Controll Bits
     - `SYN`: 연결을 시작할 때, 사용합니다.
     - `ACK`: 데이터 혹은 연결 요청에 대한 수신 확인을 나타냅니다.
     - `FIN`: 연결 종료 의사를 나타냅니다.
     - `PSH`
     - `RST`
     - `CWR`
     - `ECE`
     - `URG`
  7. Windows Size
     - 한 번에 수신할 수 있는 데이터의 크기
  8. Checksum
     - 데이터 손상 여부 확인
- 전송 속도를 조정하며, 데이터가 손실되거나 손상되면 이를 재전송하여 신뢰성을 보장합니다.<br>
  (수신 측에서 응답이 오지 않을 경우, 송신자는 가장 최근에 정상적으로 응답을 받은 데이터 이후부터 재전송을 시작합니다.)
- 흐름 제어<br>: 클라이언트 측에서는 응답을 보낼 때, 윈도우 사이즈를 설정하여 현재 받을 수 있는 데이터양을 송신 측에 수시로 알려줍니다.
  - 만약 버퍼가 가득 차면 윈도우 사이즈가 0으로 설정되고 데이터 전송이 멈추게 됩니다.
  - 전송 재개 시점은 송신 측에서 `탐색 패킷(윈도우 프로브)`을 보내 클라이언트에게 응답을 받아, 현재 윈도우 사이즈를 확인한 후 전송 재개 여부 결정합니다.

### 3-way handshake

- TCP 통신은 커넥션 연결에서 시작하며, 커넥션을 맺을 때, 원활한 통신을 위해 `일련번호`와 `최대 세그먼트 크기(MSS)`를 서로 합의하고 조율하는 과정을 거칩니다.
- 클라이언트는 `SYN` 플래그를 설정한 세그먼트를 보내어 연결을 요청하고, 서버는 `SYN-ACK` 플래그를 설정한 세그먼트로 응답합니다. 이후, 클라이언트는 `ACK` 플래그를 설정한 세그먼트를 보내어 연결을 확립합니다.

## UDP

- 동영상 스트리밍처럼 빠른 전송 속도가 필요하고 데이터 신뢰성이 상대적으로 덜 중요한 애플리케이션에 적합합니다.
- `데이터 그램`<br>
<img src = "https://github.com/user-attachments/assets/fb7a0a51-b47f-4355-809a-0dc263e77968" width="600"><br>
- 패킷 전송 방식의 다양성
  - `브로드캐스트`: 네트워크 내 모든 호스트에 패킷을 전송
  - `멀티캐스트`: 특정 그룹에 속한 다수의 호스트에 패킷을 전송

# 인터넷 계층(Internet Layer)

- IP 주소를 통해 패킷을 목적지까지 전달하는 역할을 합니다.
- `라우터`
  - 서로 다른 네트워크 간에 패킷을 전달하며 목적지까지의 경로를 찾습니다.<br>(이러한 과정을 `라우팅`이라고 합니다.)
  - 라우터는 `라우팅 테이블`을 저장하고 있으며, 이 테이블에는 목적지 호스트가 속한 네트워크 정보와 그 네트워크에 도달하기 위해 경유해야 하는 라우터의 정보가 들어있습니다.
  - 만약 라우팅 테이블에 목적지 정보가 없으면, `디폴트 라우터`로 패킷을 전달하여 경로를 찾습니다.<br>(디폴트 라우터 정보는 라우터마다 정적으로 설정되어 있습니다.)

## IPv4

- `32비트` 주소 체계인 인터넷 프로토콜입니다.
- 32비트를 `8비트씩` `4개로` 나누어 `10진수`로 변환하여 표기합니다.
- `패킷`<br>
<img src="https://github.com/user-attachments/assets/546da5ac-c76c-4bae-97a6-7cc168e46bfb" width="600"><br>
  1. 버전 (여기서는 4)
  2. IP 헤더의 길이
  3. 패킷 전체의 길이
  4. `식별자`, `플래그`, `프래그먼트 옵셋`은 데이터가 분할된 경우에 사용합니다.
  5. 패킷을 전달할 프로토콜
  6. 송신지 IP 주소
  7. 수신지 IP 주소

## IPv6

- `128비트` 주소 체계인 인터넷 프로토콜입니다.
- 128비트를 `16비트씩` `8개로` 나누어 `16진수`로 표기합니다.<br>(각 16비트 부분에 4자리의 16진수 숫자가 들어가, 총 32자리의 16진수로 구성됩니다.)
- `패킷`<br>
<img src="https://github.com/user-attachments/assets/7239fbba-dfd2-40cd-8b90-869f6994bb9b" width="600"><br>
  1. 버전 (여기서는 6)
  2. IPv6 헤더를 제외한 데이터 부분의 길이
  3. IPv4의 `Time to Live`와 같은 역할
  4. 옵션을 지정<br>(IPv6는 라우터에서 데이터를 분할하지 않는 방식으로 사양이 만들어져 있어서 분할 관련 필드는 옵션으로 되어 있습니다.) 

<br>

> IPv4와 IPv6는 서로 다른 주소 체계와 구조를 가지고 있기 때문에 직접적으로 호환되지 않습니다. 따라서 `듀얼스택`이나 `터널링` 같은 기법을 사용해야 합니다.


# 네트워크 접근 계층(Network Access Layer)