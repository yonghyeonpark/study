# 메모리 관리 기법

## 가상 메모리

- 가상 메모리는 프로세스가 실제 물리 메모리보다 큰 주소 공간을 사용할 수 있도록 지원하는 메모리 관리 기술입니다.
- 가상 메모리 기법에서 프로세스 일부는 실제 메모리에 적재되며, 나머지는 디스크의 스왑 영역에 존재할 수 있습니다.
- 프로세스의 주소 공간을 메모리에 적재하는 단위에 따라 페이징 또는 세그먼테이션 방식으로 구현될 수 있습니다.

### 스와핑

- 스와핑은 실행 중인 프로세스를 메인 메모리와 디스크의 스왑 영역 사이에서 교체하는 방식입니다.
- 스왑 아웃
  - 실행 중인 프로세스를 메모리에서 디스크의 스왑 영역으로 내보내는 작업입니다.
- 스왑 인
  - 디스크의 스왑 영역에 있던 프로세스를 다시 메인 메모리로 불러오는 작업입니다.

### 연속 메모리 할당

- 프로세스에게 연속된 단일 블록의 메모리를 할당하는 기법입니다.
- 단점
  - 외부 단편화가 발생할 수 있습니다.
  - 물리 메모리보다 큰 프로세스는 실행할 수 없습니다.

#### 연속 메모리 할당 전략

- 최초 적합
  - 공간을 검색하여 첫 번째로 적절한 위치에 할당하는 방식입니다.
  - 공간 검색을 최소화하여 빠른 할당을 할 수 있다는 장점이 있습니다.

- 최적 적합
  - 적재할 수 있는 가장 작은 공간을 찾아 할당하는 방식입니다. 

- 최악 적합
  - 공간 중 가장 큰 공간을 찾아 할당하는 방식입니다.

#### 외부 단편화

- 외부 단편화는 메모리 할당과 해제 과정에서 작은 공간들이 불연속적으로 분포하여, 충분한 전체 공간이 있음에도 큰 연속된 블록을 할당할 수 없는 현상을 의미합니다.
- 해결 방법
  - **Compaction**
    - 메모리에 있는 프로세스들을 한쪽으로 몰아서 연속된 큰 공간을 만드는 방법입니다.
    - 프로세스를 재배치하므로 성능 저하가 발생할 수 있습니다.
  - **가상 메모리 관리 기법 활용**
    - 페이징
    - 세그먼테이션

### 페이징

- 페이징은 가상 메모리 기법의 하나로, 프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누고, 물리적 메모리를 같은 크기의 프레임으로 나누어 페이지를 프레임에 매핑하는 방식입니다.
- 메모리를 불연속적으로 할당하여 외부 단편화를 방지할 수 있습니다.
- 프로세스 실행을 위해 모든 페이지가 메모리에 적재될 필요가 없으므로, 물리 메모리보다 큰 프로세스도 실행할 수 있습니다.
- 페이징에서의 스와핑은 프로세스 전체가 아니라 페이지 단위로 이루어집니다.
- 기본적으로 페이지의 크기는 모두 일정하지만, 대형 페이지라는 예외가 존재하긴 합니다.

#### 페이지 테이블

- CPU는 프로세스가 사용하는 페이지가 어느 프레임에 위치하는지 직접 알 수 없으므로, 페이지 테이블을 이용해 논리 주소를 물리 주소로 변환합니다.
- 프로세스마다 개별적인 페이지 테이블을 가지며, PTBR(`Page Table Base Register`)이 해당 테이블의 시작 주소를 가리킵니다.
- 페이지 테이블이 메모리에 저장되면, 주소 변환 과정에서 두 번의 메모리 접근이 필요합니다.
  1. 페이지 테이블에서 프레임 번호를 찾기 위해
  2. 해당 프레임에 저장된 실제 데이터에 접근하기 위해
  - TLB(Translation Look-aside Buffer)
    - 이러한 문제를 해결하기 위해 `TLB`라는 캐시 메모리를 사용합니다.
    - TLB는 페이지 테이블의 일부를 캐싱하여 주소 변환 속도를 높입니다. (TLB 히트)
    - 다만, TLB 미스가 발생하면 여전히 두 번의 메모리 접근이 필요합니다.

#### 페이지 테이블 엔트리 정보

- 페이지 번호 및 프레임 번호
- 유효 비트
  - 페이지가 현재 메모리에 존재하는지 여부를 나타냅니다.
  - 유효 비트가 0이면 해당 페이지는 스왑 영역에 있으며, 접근 시 페이지 폴트가 발생합니다.
  - 페이지 폴트 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤, 유효 비트를 1로 변경합니다.
- 보호 비트
  - 페이지에 대한 읽기/쓰기/실행 권한을 나타냅니다.
- 참조 비트
  - 페이지의 최근 참조 여부를 나타냅니다.
- 수정 비트(Dirty Bit)
  - 페이지에 쓰기 작업이 발생했는지 여부를 나타냅니다.
  - 페이지가 스왑될 때, 수정된 경우에는 디스크에 저장해야 하지만, 수정되지 않았다면 디스크에 반영할 필요 없이 단순히 메모리에서 제거하여 처리할 수 있습니다.

> 페이지 폴트란 프로세스가 접근하려는 페이지가 메모리에 없을 때 발생하는 인터럽트입니다.

#### 페이징의 장점

- **외부 단편화 해결**
  - 페이징은 메모리를 일정한 크기로 나누어 할당하므로 외부 단편화가 발생하지 않습니다.
  - 불연속적인 메모리 할당이 가능해 효율적인 메모리 활용이 가능합니다.
  - 단, 마지막 페이지의 일부 공간이 낭비되는 `내부 단편화`가 발생할 수 있으나, 일반적으로 외부 단편화보다는 낭비가 적습니다.
- **쓰기 시 복사(Copy On Write) 가능**
  - 일반적인 fork() 연산의 문제점
    - fork()를 호출하여 자식 프로세스를 생성할 때, 부모 프로세스의 메모리 공간을 그대로 복사합니다.
    - 이 과정에서 시간이 오래 걸릴 수 있고, 동일한 내용이 메모리에 중복으로 올라가 비효율적입니다.
  - 쓰기 시 복사<br>
    <img src="https://github.com/user-attachments/assets/fdcfcd59-7f2a-4030-884a-f32fe005c225" width="600"><br>
    - 자식 프로세스가 생성될 때, 부모 프로세스와 동일한 프레임을 공유하도록 설정합니다.
    - 이후, 실제 쓰기 작업이 발생할 때만 해당 페이지를 복사하여 불필요한 복사를 방지합니다.
- **계층적 페이징을 통한 메모리 절약**
  - 모든 페이지 테이블 엔트리를 메모리에 유지하는 것은 비효율적입니다.
  - 계층적 페이징을 통해 필요한 페이지 테이블만 메모리에 유지할 수 있습니다.
  - 하지만, 계층이 많아질수록 페이지 폴트 발생 시 메모리 접근 횟수가 증가하여 성능 저하가 발생할 수 있습니다.<br>
    <img src="https://github.com/user-attachments/assets/45569cfe-5478-4082-a890-1cb4c9763d89" width="600"><br>

### 세그먼테이션

- 일정한 크기의 페이지가 아닌, 코드, 데이터, 스택 등 논리적인 단위(세그먼트)로 나누어 메모리를 할당하는 방식입니다.
- 장점
  - 논리적 의미 단위로 메모리를 관리하므로, 프로세스 간 주소 공간을 효율적으로 공유할 수 있습니다.
  - 세그먼트별로 개별적인 접근 권한(읽기/쓰기/실행)을 설정할 수 있어 보안 관리에 유리합니다.
- 단점
  - 세그먼트의 크기가 일정하지 않기 때문에 외부 단편화가 발생할 수 있습니다.

## 참고

- [혼자 공부하는 컴퓨터구조 + 운영체제](https://www.inflearn.com/course/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)