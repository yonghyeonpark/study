# 동기화

## synchronized

- 자바에서 모든 객체는 내부에 자신만의 락(모니터)을 가지고 있습니다.
- `synchronized` 키워드를 사용하면 한 번에 하나의 스레드만 실행할 수 있는 코드 구간을 만들 수 있습니다.
- 스레드가 `synchronized` 메서드를 실행하기 위해서는 반드시 해당 객체의 락을 획득해야 하며, 이를 통해 한 번에 하나의 스레드만 메서드에 접근할 수 있습니다.
- 스레드는 락을 획득할 때 까지 `BLOCKED` 상태로 대기하며, 락을 다시 확득하기 전까지는 CPU 실행 스케줄링에 포함되지 않습니다. (무한정 대기)
- 락을 획득하면 `RUNNABLE` 상태가 되고 다시 코드를 실행할 수 있습니다. 단, 락을 획득하는 순서는 보장되지 않습니다.

> 참고로 지역 변수는 스택 영역에 생성되는데, 각 스레드는 독립적인 스택 영역을 가지므로 동기화를 신경 쓰지 않아도 됩니다.

### 적용 방법

- 메서드 단위로 적용
  - `public synchronized void method() {}`
- 코드 블럭으로 적용
  - `synchronized (this) {}`

### 장점

- 사용이 편리합니다.
- `synchronized` 메서드나 블록이 종료될 때 자동으로 락이 해제됩니다.

### 단점

- `BLOCKED` 상태의 스레드는 락이 해제될 때까지 무한정 대기해야 합니다. (타임아웃 설정이나 인터럽트가 불가능)
- 어떤 스레드가 락을 획득할지 예측할 수 없습니다.

## Lock 인터페이스

- 동시성 프로그래밍에서 안전한 임계 영역을 위한 락을 구현하는 데 사용됩니다.
- 대표적인 구현체로 `ReentrantLock`이 있습니다.

### 메서드

- **void lock()**
  - 락 획득을 시도하며, 다른 스레드가 이미 락을 획득했다면 락이 풀릴 때까지 현재 스레드는 `WAITING` 상태로 대기합니다. (인터럽트에 응답하지 않습니다.)
  - 대기 중인 스레드에 인터럽트가 발생하면 아주 짧은 순간 `WAITING`에서 `RUNNABLE` 상태가 되는데, `lock()` 메서드 안에서 해당 스레드를 다시 `WAITING` 상태로 강제 변경하여 인터럽트를 무시합니다.
- **void lockInterruptibly()**
  - 락 획득을 시도하면서 다른 스레드의 인터럽트를 허용합니다.
  - 대기 중 인터럽트가 발생하면 `InterruptedException`이 발생하며 락 획득을 중단합니다.
- **boolean tryLock()**
  - 락 획득을 시도하고, 즉시 그 결과(성공 여부)를 반환합니다.
- **boolean tryLock(long time, TimeUnit unit)
  - 지정된 시간 동안 락 획득을 시도하며, 성공 시 `true`를 반환합니다.
  - 대기 중 인터럽트가 발생하면 `InterruptedException`이 발생하며 락 획득을 중단합니다.
- **void unlock()**
  - 획득한 락을 해제합니다.
  - 반드시 락을 보유한 스레드가 호출해야 하며, 그렇지 않으면 `IllegalMonitorStateException`이 발생합니다.
- **Condition newCondition()**
  - `Condition` 객체를 생성하여 반환합니다.
  - `Condition` 객체는 락과 연계되어 스레드의 조건부 대기와 신호 전달을 관리합니다.
  - `Object` 클래스의 `wait()`, `notify()`, `notifyAll()`와 유사한 기능을 제공합니다.

### 무한 대기 문제 해결

- 타임아웃 설정이나 인터럽트 허용 등 다양한 메서드를 활용하여 무한 대기 상황을 방지할 수 있습니다.

### 공정성 문제 해결

- 객체 생성 시, `Boolean` 파라미터로 공정성 모드를 선택할 수 있습니다.
- 비공정 모드
  - 기본 설정이며, 락 요청 순서와 획득 순서 간의 관계를 보장하지 않습니다.
  - 특정 스레드가 지속적으로 락을 획득하지 못하는 기아 현상이 발생할 수 있습니다.
  - 락 획득 처리 속도가 빠릅니다.
  - 비공정 모드여도 일반적으로는 요청 순서대로 처리되나, 스레드 경합이 심한 상황에서는 새로운 요청이 먼저 처리될 수 있습니다.
- 공정 모드
  - 생성자에 `true`를 전달하여 활성화합니다. (`new ReentrantLock(true)`)
  - 락 요청 순서대로 획득을 보장하지만, 성능 저하가 발생할 수 있습니다.
  - 처리 속도는 더 느리지만 모든 스레드에 공정한 기회를 제공합니다.

## 참고

- [김영한 - 실전 자바 고급 1편]https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B3%A0%EA%B8%89-1/dashboard)