# 자바 동기화

## 메모리 가시성 문제

- 멀티스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에서 언제 보이는지에 대한 문제를 말합니다.

### 원인

- 현대 CPU 대부분은 코어 단위로 캐시 메모리를 각각 보유하고 있습니다.
- 변수 값을 읽거나 변경할 때, 먼저 캐시 메모리에 로드한 후 연산을 수행합니다.
- 여러 스레드가 같은 변수를 사용하면 각각의 캐시 메모리에 값을 따로 저장하고, 변경된 값이 메인 메모리에 즉시 반영되지 않을 수 있습니다.
- 이로 인해 한 스레드에서 변경한 값이 다른 스레드에서 언제 보이는지 보장할 수 없는 상황이 발생합니다.

### 해결 방법

- volatile 키워드 사용
  - 변수를 `volatile`로 선언하면, 값을 읽거나 쓸 때 항상 메인 메모리에 직접 접근합니다.
  - 즉, 캐시를 거치지 않고 최신 값을 보장할 수 있습니다.
  - 다만, 성능 저하가 발생할 수 있으므로 꼭 필요한 변수에만 사용하는 것이 좋습니다.
- `synchronized` 키워드 또는 Lock 인터페이스 사용

## synchronized

- 자바에서 모든 객체는 멀티스레드와 임계 영역을 다루기 위해 내부에 3가지 기본 요소를 가집니다.
  - 모니터 락
  - 모니터 락 대기 집합
  - 스레드 대기 집합
- `synchronized` 키워드를 사용하면 한 번에 하나의 스레드만 실행할 수 있는 코드 구간을 만들 수 있습니다.
- 스레드가 `synchronized` 메서드를 실행하기 위해서는 반드시 해당 객체의 락을 획득해야 하며, 이를 통해 한 번에 하나의 스레드만 메서드에 접근할 수 있습니다.
- 스레드는 락을 획득할 때 까지 `BLOCKED` 상태로 대기하며, 락을 다시 확득하기 전까지는 CPU 실행 스케줄링에 포함되지 않습니다. (무한정 대기)
- 락을 획득하면 `RUNNABLE` 상태가 되고 다시 코드를 실행할 수 있습니다. 단, 락을 획득하는 순서는 보장되지 않습니다.

> 참고로 지역 변수는 스택 영역에 생성되는데, 각 스레드는 독립적인 스택 영역을 가지므로 동기화를 신경 쓰지 않아도 됩니다.

### 적용 방법

- 메서드 단위로 적용
  - `public synchronized void method() {}`
- 코드 블럭으로 적용
  - `synchronized (this) {}`

### 장점

- 사용이 편리합니다.
- `synchronized` 메서드나 블록이 종료될 때 자동으로 락이 해제됩니다.

### 단점

- `BLOCKED` 상태의 스레드는 락이 해제될 때까지 무한정 대기해야 합니다. (타임아웃 설정이나 인터럽트가 불가능)
- 어떤 스레드가 락을 획득할지 예측할 수 없습니다.

## Lock 인터페이스

- 동시성 프로그래밍에서 안전한 임계 영역을 위한 락을 구현하는 데 사용됩니다.
- 대표적인 구현체로 `ReentrantLock`이 있습니다.

### 메서드

- **void lock()**
  - 락 획득을 시도하며, 다른 스레드가 이미 락을 획득했다면 락이 풀릴 때까지 현재 스레드는 `WAITING` 상태로 대기합니다. (인터럽트에 응답하지 않습니다.)
  - 대기 중인 스레드에 인터럽트가 발생하면 아주 짧은 순간 `WAITING`에서 `RUNNABLE` 상태가 되는데, `lock()` 메서드 안에서 해당 스레드를 다시 `WAITING` 상태로 강제 변경하여 인터럽트를 무시합니다.
- **void lockInterruptibly()**
  - 락 획득을 시도하면서 다른 스레드의 인터럽트를 허용합니다.
  - 대기 중 인터럽트가 발생하면 `InterruptedException`이 발생하며 락 획득을 중단합니다.
- **boolean tryLock()**
  - 락 획득을 시도하고, 즉시 그 결과(성공 여부)를 반환합니다.
- **boolean tryLock(long time, TimeUnit unit)
  - 지정된 시간 동안 락 획득을 시도하며, 성공 시 `true`를 반환합니다.
  - 대기 중 인터럽트가 발생하면 `InterruptedException`이 발생하며 락 획득을 중단합니다.
- **void unlock()**
  - 획득한 락을 해제합니다.
  - 반드시 락을 보유한 스레드가 호출해야 하며, 그렇지 않으면 `IllegalMonitorStateException`이 발생합니다.
- **Condition newCondition()**
  - `Condition` 객체를 생성하여 반환합니다.
  - `Condition` 객체는 락과 연계되어 스레드의 조건부 대기와 신호 전달을 관리합니다.
  - `Object` 클래스의 `wait()`, `notify()`, `notifyAll()`와 유사한 기능을 제공합니다.

### 무한 대기 문제 해결

- 타임아웃 설정이나 인터럽트 허용 등 다양한 메서드를 활용하여 무한 대기 상황을 방지할 수 있습니다.

### 공정성 문제 해결

- 객체 생성 시, `Boolean` 파라미터로 공정성 모드를 선택할 수 있습니다.
- 비공정 모드
  - 기본 설정이며, 락 요청 순서와 획득 순서 간의 관계를 보장하지 않습니다.
  - 특정 스레드가 지속적으로 락을 획득하지 못하는 기아 현상이 발생할 수 있습니다.
  - 락 획득 처리 속도가 빠릅니다.
  - 비공정 모드여도 일반적으로는 요청 순서대로 처리되나, 스레드 경합이 심한 상황에서는 새로운 요청이 먼저 처리될 수 있습니다.
- 공정 모드
  - 생성자에 `true`를 전달하여 활성화합니다. (`new ReentrantLock(true)`)
  - 락 요청 순서대로 획득을 보장하지만, 성능 저하가 발생할 수 있습니다.
  - 처리 속도는 더 느리지만 모든 스레드에 공정한 기회를 제공합니다.

## BlockingQueue 인터페이스

- BlockingQueue는 스레드가 데이터를 추가할 공간이 없거나 꺼낼 데이터가 없을 때 자동으로 대기하는 기능을 제공하여, 생산자-소비자 패턴 구현에 최적화된 인터페이스입니다.

### 대표적인 구현체

- **ArrayBlockingQueue**
  - 고정된 크기의 버퍼를 사용합니다.
  - 공정 모드 선택이 가능합니다.
- **LinkedBlockingQueue**
  - 버퍼 크기를 고정하거나 무제한으로 설정할 수 있습니다.

### 큐가 가득 차거나 비어 있을 때의 처리 방식

1. 예외 발생
   - add(d)
     - 데이터를 큐에 추가할 때, 큐가 가득 차 있으면 `IllegalStateException`이 발생합니다.
   - remove()
     - 큐에서 데이터를 꺼낼 때, 큐가 비어 있으면 `NoSuchElementException`이 발생합니다.
   - element()
     - 큐에서 데이터를 직접 꺼내지 않고 확인만 하는데, 큐가 비어 있으면 `NoSuchElementException`이 발생합니다.
2. 즉시 반환
   - offer(d)
     -  데이터를 큐에 추가할 때, 큐가 가득 차 있으면 `false`를 반환합니다.
   - poll()
     - 큐에서 데이터를 꺼낼 때, 큐가 비어 있으면 `null`을 반환합니다.
   - peek()
     - 큐에서 데이터를 직접 꺼내지 않고 확인만 하는데, 큐가 비어 있으면 `null`을 반환합니다.
3. 무한 대기
   - put(d)
     - 데이터를 큐에 추가할 수 있을 때까지 무한정 대기합니다.
   - take()
     - 큐에서 데이터를 꺼낼 때, 큐가 비어 있으면 데이터가 준비될 때까지 무한정 대기합니다.
4. 일정 시간만 대기
   - offer(d, time, unit)
     - 데이터를 큐에 추가할 때, 설정된 시간 동안 대기하다가, 시간이 초과되면 `false`를 반환합니다.
   - poll(time, unit)
     - 큐에서 데이터를 꺼낼 때, 설정된 시간 동안 대기하다가, 시간이 초과되면 `null`을 반환합니다.

## 참고

- [김영한 - 실전 자바 고급 1편](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B3%A0%EA%B8%89-1/dashboard)