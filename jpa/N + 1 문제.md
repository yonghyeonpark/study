# N + 1 문제

- JPA의 N + 1 문제는 연관관계가 설정된 엔티티를 조회할 때 발생하는 성능 문제입니다.
- 하나의 쿼리로 조회한 엔티티와 연관된 N개의 엔티티를 가져오기 위해 추가로 N 번의 쿼리가 실행되는 현상을 말합니다.

## 즉시로딩과 N + 1

- JPQL은 SQL을 생성할 때 엔티티의 페치 전략을 고려하지 않고 해당 엔티티만을 조회합니다.
- 연관 엔티티가 즉시로딩으로 설정되어 있다면, 최초 조회된 엔티티가 애플리케이션에 로딩된 직후 연관 엔티티를 조회하기 위한 추가 쿼리가 발생합니다.
- 이때 처음 조회한 엔티티의 수만큼 추가 쿼리가 발생하게 되어 N + 1 문제라고 부릅니다.

## 지연로딩과 N + 1

- 지연로딩을 사용하면 JPQL 실행 시점에는 N + 1 문제가 발생하지 않습니다.
- 대신 기준 엔티티만 조회되고, 이후 비즈니스 로직에서 연관 엔티티를 실제로 사용할 때 추가 쿼리가 실행됩니다.
- 하지만 연관 엔티티를 사용하는 시점에 초기화되는 엔티티 수만큼 추가 쿼리가 실행되므로, 결과적으로 동일한 N + 1 문제가 발생합니다.

## 해결 방법

### 페치 조인 사용

- 페치 조인은 연관된 엔티티를 함께 조회하는 가장 일반적인 해결책입니다.
- 단 한 번의 쿼리로 필요한 데이터를 모두 조회할 수 있어 N + 1 문제를 효과적으로 해결할 수 있습니다.

### @BatchSize 설정

- 하이버네이트의 `@BatchSize(size = ?)` 어노테이션을 사용하면 설정한 size만큼의 연관 엔티티를 SQL의 `IN` 절로 일괄 조회할 수 있습니다.
- 이는 추가 쿼리의 수를 크게 줄일 수 있는 효과적인 방법입니다.
- 애플리케이션 전역 설정도 가능합니다.
  ```yaml
  spring:
    jpa:
      properties:
        hibernate:
          default_batch_fetch_size: ?
  ```
- **vs 페치조인**
  - 페치 조인 방식보다 쿼리 호출 수는 증가하지만, 데이터베이스 전송량은 오히려 감소합니다.
  - 페치 조인과 달리 연관된 데이터를 조회할 때 중복 데이터가 발생하지 않습니다.
  - 페치 조인과 달리 컬렉션을 페이징 처리할 때도 사용할 수 있습니다.
- **size 값 설정 기준**
  - size 값을 얼마로 설정하든 전체 데이터는 모두 메모리에 로딩되므로, 총 메모리 사용량은 동일합니다.
  - 보통 100~1000 사이에서 선택하는 것을 권장하며, 데이터베이스의 `IN` 절 제한과 네트워크 환경을 고려하여 적절한 값을 선택하면 됩니다.
  - 1000으로 설정하는 것이 성능상 가장 좋지만, size 값에 따라 순간 부하가 달라지므로 애플리케이션의 부하 처리 능력을 고려하여 값을 결정하면 됩니다.

### EntityGraph 사용

- `@EntityGraph` 어노테이션을 사용하면, 필요한 연관 엔티티를 명시적으로 조회할 수 있습니다.
  ```java
  @EntityGraph(attributePaths = {"reviews"})
  List<User> findAll();
  ```

## 참고

- [자바 ORM 표준 JPA 프로그래밍](https://www.yes24.com/product/goods/19040233)
- [김영한 - JPA 활용2](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-API%EA%B0%9C%EB%B0%9C-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94)