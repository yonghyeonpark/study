# 변경 감지(Dirty Checking)

- 변경 감지는 엔티티의 변경 사항을 자동으로 감지하여 데이터베이스에 반영하는 JPA의 기능입니다.

## 동작 과정

1. 엔티티를 조회하면 `영속성 컨텍스트`에 보관됩니다. (`영속화`)
2. 이때 최초 상태를 `스냅샷`으로 복사하여 저장합니다.
3. `플러시 시점`에 스냅샷과 현재 엔티티를 비교하여 변경된 엔티티를 감지합니다.
4. 변경된 엔티티가 있다면, 수정 쿼리를 생성하여 `쓰기 지연 SQL 저장소`에 보관합니다.
5. `쓰기 지연 저장소`의 SQL을 데이터베이스로 전송합니다.
6. 데이터베이스에서 트랜잭션을 `커밋`합니다.
   (트랜잭션 `커밋` 시, `플러시`가 자동으로 호출됩니다.)

## 영속성 컨텍스트의 플러시 발생 시점

- `entityManager.flush()`를 직접 호출 시
- 트랜잭션 커밋 시
- JPQL 쿼리 실행 시

## 쓰기 지연 SQL 저장소

- 엔티티의 변경 사항을 데이터베이스에 바로 반영하지 않고, 플러시 발생까지 메모리에 모아두었다가 한 번에 처리하는 방식입니다.
- **장점**
  - 데이터베이스 커넥션 횟수 최소화
  - 데이터베이스 테이블 레코드에 락이 걸리는 시간 최소화

## JPA의 기본 수정 전략

- JPA는 기본적으로 엔티티의 모든 필드를 업데이트하는 전략을 사용합니다.
- **장점**
  - 수정 쿼리가 항상 동일하여 애플리케이션 로딩 시점에 쿼리를 미리 생성해 두고 재사용할 수 있습니다.
  - 데이터베이스에 동일한 쿼리를 보내면 이전에 파싱된 쿼리를 재사용할 수 있어 성능상 이점이 있습니다. 

### @DynamicUpdate 사용

- 엔티티의 필드가 매우 많은 경우, 기본 방식인 `정적` 수정 쿼리보다 `@DynamicUpdate`을 사용한 `동적` 수정 쿼리가 더 효율적일 수 있습니다.
- 일반적으로는 기본 전략을 사용하고, 성능 최적화가 필요할 정도로 느린 경우에만 전략을 수정하는 것을 좋습니다.
- 다만, 테이블의 컬럼 수가 성능에 성향을 줄 정도로 많다면, 이는 엔티티의 책임이 적절히 분리되지 않았을 가능성이 높습니다.

## 변경 감지와 병합(Merge)의 차이

- `변경 감지`는 기존 영속 상태의 엔티티에서 변경을 감지하여 반영하고, `병합`은 준영속 상태나 비영속 상태의 엔티티를 영속 상태로 변경할 때 사용합니다.
- `변경 감지`는 원하는 속성만 선택적으로 변경할 수 있지만, `병합`은 모든 필드가 변경되므로 의도치 않은 업데이트가 발생할 수 있습니다.

### 병합 과정

1. `em.merge()`의 파라미터로 준영속 혹은 비영속 엔티티를 전달합니다. 
2. 해당 준영속 엔티티의 식별자 값으로 영속성 컨텍스트에서 엔티티를 조회합니다. 
3. 영속성 컨텍스트에 없다면 데이터베이스에서 조회해서 영속 엔티티를 가져옵니다.
4. 만약 데이터베이스에서도 발견하지 못하면 새로운 엔티티를 생성합니다.
5. 가져온 영속 엔티티에 1.의 엔티티 값을 채워 넣습니다.

## 참고

- [자바 ORM 표준 JPA 프로그래밍](https://www.yes24.com/product/goods/19040233)