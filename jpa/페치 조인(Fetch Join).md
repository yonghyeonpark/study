# 페치 조인(Fetch Join)

- 페치 조인은 SQL 조인의 한 종류가 아니라 JPQL에서 제공하는 성능 최적화를 위한 기능입니다.
- 하나의 SQL 문으로 연관된 엔티티들을 함께 조회할 수 있어 성능상 이점이 있으며, 주로 객체 그래프를 유지할 때 사용하는 것이 좋습니다.
- 만약 여러 테이블을 조인하여 엔티티의 구조와 다른 결과가 필요한 경우에는, 페치 조인보다는 일반 조인을 사용하고 필요한 데이터들만 DTO로 반환하는 것이 더 효과적입니다.

## 컬렉션 페치 조인

- 일대다 관계에서 컬렉션을 페치 조인하면 데이터가 중복되어 조회될 수 있습니다.
- 예를 들어, `TeamA`에 `MemberA`, `MemberB`가 소속된 경우, 다음과 같은 쿼리는

  ```jpaql
  SELECT t
  FROM Team t JOIN FETCH t.members
  WHERE t.name = 'TeamA'
  ```
  아래와 같이 2건의 중복된 결과를 반환합니다.
  ```text
  [결과]
  TeamA, {MemberA, MemberB}
  TeamA, {MemberA, MemberB}
  ```

### DISTINCT를 활용한 중복 제거

- 위와 같은 중복 문제를 해결하기 위해 `DISTINCT` 키워드를 사용할 수 있습니다.
- JPQL의 `DISTINCT`는 SQL에 `DISTINCT`를 추가함과 동시에 애플리케이션 레벨에서도 중복을 제거합니다.
- 각 행의 데이터가 서로 다르므로 SQL의 `DISTINCT`만으로는 중복 제거 효과를 볼 수 없습니다.<br>
  <img src="https://github.com/user-attachments/assets/2a9d8006-59d8-4846-9231-af0bef013d7b" width = 350><br>
- 하지만 애플리케이션에서 `DISTINCT` 명령어를 보고 중복된 데이터를 걸러내어, 중복된 Team 엔티티를 제거하게 됩니다.

>💡 하이버네이트 6부터는 `DISTINCT` 없이도 애플리케이션에서 자동으로 중복 제거가 이루어집니다.

## 일반 조인과의 차이점

- 아래 쿼리처럼 페치 조인을 사용하지 않고 일반 조인을 사용하면, 연관 데이터는 함께 조회되지 않습니다.
  ```jpaql
  select t
  FROM Team t JOIN t.members
  WHERE t.name = 'TeamA'
  ```
- 이때 연관관계의 페치 전략에 따라 동작이 달라집니다.
  - 즉시로딩으로 설정하면 추가 쿼리를 실행합니다.
  - 지연로딩으로 설정하면 프록시 또는 초기화되지 않은 컬렉션 래퍼를 반환합니다.

## 페치 조인의 한계

### 별칭 사용의 제약

- JPA 표준 스펙에서는 페치 조인 대상에 별칭을 사용할 수 없습니다.
- 하이버네이트는 이를 허용하지만, 별칭을 잘못 사용하면 연관된 데이터 수가 달라져서 데이터 무결성이 깨질 수 있으므로 가급적 사용하지 않는 것이 좋습니다.
- `ON` 절 사용이 불가능하며, `WHERE` 절은 사용 가능하지만, 페치 조인의 대상을 사용해서는 안 됩니다.

### 다중 컬렉션 페치 조인 제약

- 구현체에 따라 가능하기도 하지만, 하이버네이트에서는 `MultipleBagFetchException`이 발생합니다.
- 두 개 이상의 컬렉션을 조인하면 카테시안 곱이 발생할 수 있어 주의가 필요합니다.

### 페이징 처리의 제약

- 하이버네이트에서 컬렉션을 페치 조인하고 페이징 API를 사용하면 경고 로그를 남기면서 `메모리`에서 페이징을 처리합니다.
- 쿼리 결과를 전부 메모리에 올린 후 애플리케이션에서 페이징 처리를 하므로 성능 이슈와 메모리 초과 위험이 있습니다.

## 참고

- [자바 ORM 표준 JPA 프로그래밍](https://www.yes24.com/product/goods/19040233)